<html>

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0" />
	<link rel="stylesheet" href="example.css" />
	<title>a* 算法演示</title>
</head>

<body>
	<center>
		<canvas id="map-draw"></canvas>
		<br />
		宽<input type="number" id="map-mapX" value="10" />
		高<input type="number" id="map-mapY" value="10" />
		<input type="checkbox" id="map-smooth" />简化
		<input type="range" min=-2.0 max=2.0 value=0.0 step=0.001 style="width: 100%;" id="playbackrate" />简化
	</center>
	<!--<script src="pkg\wasm_odessay_jps.js"></script>
	<script src="example.js"></script>-->
	<br />
	<pre id=spark></pre>
	<canvas width=600 height=100 style=width:100% id=view />
	<script>
		window.addEventListener('error', function(a) {
			alert(a.message);
		});
		window.addEventListener('unhandledrejection', function(a) {
			alert(a.reason.message);
		});

	</script>
	<script>
		let source;

		function dump(f) {
			return 'data:text/javascript;base64,' + btoa('(' + f.toString().replace(/[^\x01-\xfe]/g, "?") + ')()');
		}


		function xyz() { // white-noise-processor.js
			// https://zhuanlan.zhihu.com/p/347091298

			function cadd(a, b) {
				return [a[0] + b[0], a[1] + b[1]];
			}

			function csub(a, b) {
				return [a[0] - b[0], a[1] - b[1]];
			}

			function cmul(a, b) {
				return [a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]];
			}

			function FFT(a, n, inv) //inv为虚部符号，inv为1时FFT，inv为-1时IFFT
			{
				if (n == 1) //如果需要转换的只有一项就直接返回
					return;
				let mid = n / 2;
				let A1 = [],
					A2 = [];
				for (let i = 0; i < n; i += 2) //拆分多项式
				{
					A1.push(a[i]);
					A2.push(a[i + 1]);
				}
				FFT(A1, mid, inv); //递归分治
				FFT(A2, mid, inv);
				let w0 = [1, 0],
					wn = [Math.cos(2 * Math.PI / n), inv * Math.sin(2 * Math.PI / n)]; //单位根
				for (let i = 0; i < mid; ++i, w0 = cmul(w0, wn)) //合并多项式
				{
					a[i] = cadd(A1[i], cmul(w0, A2[i]));
					a[i + n / 2] = csub(A1[i], cmul(w0, A2[i]));
				}
			}

			function pitch(inp, K, that) {
				let a = [],
					b = [];
				// Don't use map()
				inp.forEach(x => a.push([x, 0]));
				FFT(a, a.length, 1);
				const U = Math.floor,
					V = x => U(x) + 1,
					I = Math.abs,
					S = Math.sqrt;
				if (K >= 1) {
					for (let i = 0; i < a.length / 2; i++) {
						let p = i / K;
						b.push(
							cadd(
								cmul(a[U(p)], [(1 - I(p - U(p))), 0]),
								cmul(a[V(p)], [(1 - I(p - V(p))), 0])
							)
						);
					}
					for (let i = a.length / 2; i < a.length; i++) {
						let p = a.length - (a.length - i) / K;
						b.push(
							cadd(
								cmul(a[U(p)], [(1 - I(p - U(p))), 0]),
								cmul(a[V(p) % a.length], [(1 - I(p - V(p))), 0])
							)
						);
					}
				} else {
					b = Array(a.length).fill([0.0, 0.0]);
					for (let i = 0; i < a.length / 2; i++) {
						let p = i * K;
						b[U(p)] = cadd(
							b[U(p)],
							cmul(a[i], [(1 - I(p - U(p))), 0])
						);
						b[V(p)] = cadd(
							b[V(p)],
							cmul(a[i], [(1 - I(p - V(p))), 0])
						);
					}
					for (let i = a.length / 2; i < a.length; i++) {
						let p = a.length - (a.length - i) * K;
						b[U(p)] = cadd(
							b[U(p)],
							cmul(a[i], [(1 - I(p - U(p))), 0])
						);
						b[V(p) % a.length] = cadd(
							b[V(p) % a.length],
							cmul(a[i], [(1 - I(p - V(p))), 0])
						);
					}
				}
				that.port.postMessage([a, b]);
				a = b;
				FFT(a, a.length, -1);
				return a.map(x => x[0] / a.length);
			}

			// ----7-2-5---5-----6-4---2-----------7--2-5---5-----6--4-1-2-----------2-4-5-----5-4---4---2-7---6-5---4-3-2-------1-----7-7-------

			// 7---2---2---1---7-----

			class WhiteNoiseProcessor extends AudioWorkletProcessor {
				constructor() {
					super();
					let that = this;
					this.port.onmessage = function(mess) {
						that.diaozi = mess.data;
					};
					this.buff = new Float64Array(1024).fill(0.0);
					this.ptr = 0;
					this.diaozi = 0.0;
				}
				process(inputs, outputs, parameters) {
					try {
						const input = inputs[0]
						const output = outputs[0]
						if (input.length === 0) {
							throw new Error("playback stopped");
						}
						for (let i = 0; i < input[0].length; ++i) {
							output[0][i] = this.buff[i + this.ptr];
							this.buff[i + this.ptr] = input[0][i];
						}
						this.ptr += input[0].length;
						if (this.ptr >= 1024) {
							this.buff = pitch(this.buff, Math.pow(2, this.diaozi), this);
							this.ptr = 0;
						}
						for (let channel = 1; channel < output.length; ++channel) {
							for (let i = 0; i < input[channel].length; ++i) {
								output[channel][i] = output[0][i];
							}
						}
						return true;
					} catch (e) {
						this.port.postMessage(e.message);
						return true;
					}
				}
			}

			registerProcessor('white-noise-processor', WhiteNoiseProcessor);
			//return pitch(arguments[0], arguments[1]);
		}

		/*a=	xyz([1,2,3,4,3,2,1,2], 1);
			 out = "\n" + a.map(x=> "\n" + x.toFixed(2));
			 document.body.innerText = out;
			 throw new Error("ok");*/

		let whiteNoiseNode;

		document.getElementById("map-smooth").addEventListener("click", async function() {
			const audioCtx = new(window.AudioContext || window.webkitAudioContext)();

			const data = await (await fetch("test.wav")).arrayBuffer();
			const myArrayBuffer = await audioCtx.decodeAudioData(data);
			// Get an AudioBufferSourceNode.
			// This is the AudioNode to use when we want to play an AudioBuffer
			source = audioCtx.createBufferSource();
			// set the buffer in the AudioBufferSourceNode
			source.buffer = myArrayBuffer;
			// connect the AudioBufferSourceNode to the
			// destination so we can hear the sound

			await audioCtx.audioWorklet.addModule(dump(xyz));
			whiteNoiseNode = new AudioWorkletNode(audioCtx, 'white-noise-processor')

			whiteNoiseNode.port.onmessage = function(mess) {
				if (typeof mess.data === "object") {
					graph(mess.data);
				} else {
					spark.innerText = mess.data;
				}
			};

			whiteNoiseNode.addEventListener("processorerror", function(a) {
				alert("error");
			});

			source.connect(whiteNoiseNode).connect(audioCtx.destination);
			source.playbackRate.value = Math.pow(2, playbackrate.value);
			// start the source playing
			source.start();
			let endcall = () => {
				source.disconnect();
				source = audioCtx.createBufferSource();
				// set the buffer in the AudioBufferSourceNode
				source.buffer = myArrayBuffer;
				source.connect(whiteNoiseNode).connect(audioCtx.destination);
				source.playbackRate.value = Math.pow(2, playbackrate.value);
				source.onended = endcall;
				source.start();
			}
			source.onended = endcall;

		});

		let gview = document.getElementById("view").getContext("2d");

		function graph(data) {
			gview.clearRect(0, 0, 600, 100);
			data.forEach((arr, i) => {
				gview.beginPath();
				gview.moveTo(0, 100);
				let color = ["red", "blue"];
				for (let i = 1; i < arr.length / 2; i++) {
					let p0 = arr[i],
						p1 = arr[arr.length - i];
					let freq = 48000 * i / arr.length;
					let cdis = c => Math.sqrt(c[0] * c[0] + c[1] * c[1]);
					let power = (cdis(p0) + cdis(p1)) / arr.length;
					gview.lineTo(300 + 300 * Math.log(freq / 256) / Math.log(16),
						100 - 100 * power);
				}
				gview.moveTo(600, 100);
				gview.closePath();
				gview.strokeStyle = color[i];
				//gview.fillStyle = "#00FF00";
				gview.lineWidth = 1;
				gview.stroke();
				//gview.fill();
			});

			/*
			gview.beginPath();
			gview.moveTo(0, 100);
			for (let i = 1; i < arr.length / 2; i++) {
				let p0 = arr[i],
					p1 = arr[arr.length - i];
				let freq = 48000 * i / arr.length;
				let cdis = c => Math.sqrt( /*c[0] * c[0] + c[1] * c[1]);
				let power = (cdis(p0) + cdis(p1)) / arr.length;
				gview.lineTo(300 + 300 * Math.log(freq / 256) / Math.log(16),
					100 - 100 * power);
			}
			gview.moveTo(600, 100);
			gview.closePath();
			gview.strokeStyle = "#0000FF";
			gview.lineWidth = 1;
			gview.stroke();*/
		}

		document.getElementById("playbackrate").addEventListener("input", function() {
			whiteNoiseNode.port.postMessage(-event.target.value);
			source.playbackRate.value = Math.pow(2, event.target.value);
		});

	</script>
</body>

</html>
